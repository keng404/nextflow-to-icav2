options(stringsAsFactors=FALSE)
suppressPackageStartupMessages(library("argparse"))
library(rlog)
library(rjson)

# create parser object
parser <- ArgumentParser()

# specify our desired options 
# by default ArgumentParser will add an help option 

parser$add_argument("-j", "--json", default=NULL,
                    help="nf schema JSON generated by nf-core python library")
parser$add_argument("-o","--output-xml","--output_xml", default=NULL,
                    help = "output file name for parameters XML file")
parser$add_argument("-i","--include_hidden_parameters",action="store_true",
                    default=FALSE, help = "include all parameters in XML")
parser$add_argument("-n","--nf-core-mode","--nf_core_mode",action="store_true",
                    default=FALSE, help = "flag to indicate nf-core pipeline")
parser$add_argument("-s","--sections_override", default=c("input_output_options"),
                    action="append",help="section in schema JSON file to ensure it's presence in the output XML file")
# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults, 
args <- parser$parse_args()

if(!is.null(args$json)){
  nf_params_json = args$json
} else{
  stop(paste("EXITING: Please define a Nextflow Schema JSON file to convert to XML"))
}
#nf_params_json = "/Users/keng/nf-core/sarek/nextflow_schema.json"
rlog::log_info(paste("Step0: Reading in",nf_params_json))
json_data = fromJSON(file=nf_params_json)$definitions
generic_data  = fromJSON(file=nf_params_json)$properties
parameter_sections = names(json_data)
rlog::log_info(paste("PARAMETER_SECTIONS:",paste(parameter_sections,collapse=", ")))
#####################
returnParamMetadata <- function(param_configuration){
  param_metadata = list()
  
  #### parameter type
  if("type" %in% names(param_configuration)){
    param_metadata[["type"]] = param_configuration[["type"]]
  } else{
    param_metadata[["type"]] = "string"
  }
  #### help text describing parameter
  description_text = c()
  if("description" %in% names(param_configuration)){
    param_configuration[["description"]] = paste(strsplit(param_configuration[["description"]],"\n")[[1]],collapse="\n")
    #param_configuration[["description"]] = gsub("\n","\\n",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\"","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("`","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\\*","-",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\\*\\*\\NB\\*\\*","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("&","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub(">","",param_configuration[["description"]])
    description_text = c(description_text,param_configuration[["description"]])
  }
  if("help_text" %in% names(param_configuration)){
    param_configuration[["help_text"]] = paste(strsplit(param_configuration[["help_text"]],"\n")[[1]],collapse="\n")
    param_configuration[["help_text"]] = gsub("\"","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("\\*","-",param_configuration[["help_text"]])
    #param_configuration[["help_text"]] = gsub("\n","\\n",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("`","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub(">","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("\\*\\*\\NB\\*\\*","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("&","",param_configuration[["help_text"]])
    description_text = c(description_text,param_configuration[["help_text"]])
  }
  param_metadata[["description"]] = paste(description_text,collapse="\n")
  ### default value
  if("default" %in% names(param_configuration)){
    param_metadata[["default"]] = param_configuration[["default"]]
  } else{
    param_metadata[["default"]] = NULL
  }
  ### list of accepted settings for parameter
  if("list" %in% names(param_configuration)){
    param_metadata[["list"]] = param_configuration[["list"]]
  } else if ("enum" %in% names(param_configuration)){
    param_metadata[["list"]] = param_configuration[["enum"]]
  } else{
    param_metadata[["list"]] = NULL
  }
  return(param_metadata)
}

rlog::log_info(paste("INCLUDE_HIDDEN_PARAMETERS:",args$include_hidden_parameters))
getParams <- function(param_data,include_hidden_parameters=args$include_hidden_parameters,override_list = c(),generic_data){
  parameterConfigs = list()
  parameter_sections = names(param_data)
  ########################
  rlog::log_info(paste("Found",length(parameter_sections),"parameter Sections"))
  for(i in 1:length(parameter_sections)){
    rlog::log_info(paste("Starting to parse",parameter_sections[i],"section"))
    allParams = list()
    param_names = names(param_data[[parameter_sections[i]]][["properties"]])
    rlog::log_info(paste("Found", paste(param_names,collapse=", ")))
    if(!isTRUE(include_hidden_parameters) && !(parameter_sections[i] %in% override_list)){
      rlog::log_info(paste("Checking for required parameters"))
      if("required" %in% names(param_data[[parameter_sections[i]]])){
        param_names = param_data[[parameter_sections[i]]][["required"]]
      } else{
        param_names = NULL
      }
    }
    if(!is.null(param_names)){
      for(j in 1:length(param_names)){
        rlog::log_info(paste("Retriving info for parameter",param_names[j]))
        allParams[[param_names[j]]] = returnParamMetadata(param_data[[parameter_sections[i]]][["properties"]][[param_names[j]]])
      }
    }
    # avoid adding empty lists to our config
    if(length(allParams) > 0){
      parameterConfigs[[parameter_sections[i]]] = allParams  
    }
  }
  ### 1st attempt to include parameters from NF pipelines not in nf-core
    rlog::log_info("ADDING_HIDDEN_PARAMETERS")
    param_names = names(generic_data)
    genericParams = list()
    if(!is.null(param_names)){
      for(j in 1:length(param_names)){
        rlog::log_info(paste("Retriving info for parameter",param_names[j]))
        genericParams[[param_names[j]]] = returnParamMetadata(generic_data[[param_names[j]]])
      }
    }
    if(length(genericParams) > 0){
      parameterConfigs[["all_options"]] = genericParams  
    }
  return(parameterConfigs)
}
rlog::log_info(paste("Step1: Parsing",nf_params_json))
x = getParams(json_data,override_list = args$sections_override,generic_data =generic_data)


### Using the XML package, consider adding nodes to the prefix.xml using newXMLNode():
  
library(XML)

# parse the return object from getParams and retrieves data inputs and returns the remaining contents of getParams
retrieveDataInput <- function(param_configuration){
  param_configuration1 = param_configuration
  is_data_input = c()
  dataInputs = list()
  param_names = names(param_configuration)
  for(i in 1:length(param_names)){
    if(grepl("Path",param_configuration[[param_names[i]]][["description"]],ignore.case=T) && !grepl("*",param_configuration[[param_names[i]]][["description"]])){
      is_data_input = c(is_data_input,param_names[i])
    }
  }
  if(length(is_data_input) > 0){
    for(j in 1:length(is_data_input)){
      dataInputs[[is_data_input[j]]] = param_configuration[[is_data_input[j]]]
      param_configuration1[[is_data_input[[j]]]] = NULL
    }
  }
  retrieval_results = list()
  retrieval_results[["dataInputs"]] = dataInputs
  retrieval_results[["params"]] = param_configuration1
  return(retrieval_results)
}

#### convert getParams object into an 'Illumina parameters XML'compatible format
convertParams <- function(parsed_json){
  allParams = list()
  dataInputs = list()
  steps = list()
  for(i in 1:length(names(parsed_json))){
    converted_output = retrieveDataInput(parsed_json[[names(parsed_json)[i]]])
    if(length(converted_output[["params"]]) > 0 ){
      steps[[names(parsed_json)[i]]] = converted_output[["params"]]
    }
    if(length(converted_output[["dataInputs"]]) > 0){
      for(j in 1:length(names(converted_output[["dataInputs"]]))){
        dataInputs[[names(converted_output[["dataInputs"]])[j]]] = converted_output[["dataInputs"]][[names(converted_output[["dataInputs"]])[j]]]
      }
    }
  }
  allParams[["dataInputs"]] = dataInputs
  allParams[["steps"]] = steps
  return(allParams)
}
rlog::log_info(paste("STEP2: Converting JSON to be ready for ICA XML"))
y = convertParams(x)
data_input_configurations = y[["dataInputs"]]
if(args$nf_core_mode){
  ########### workaround add input files --- will not be used by pipeline , but by ICA to stage the data
  if(!"input" %in% names(data_input_configurations) || length(names(data_input_configurations)) == 0){
    data_input_configurations[["input_files"]] = list()
    data_input_configurations[["input_files"]][["description"]] = 'input files for pipeline.\nAll files will be staged in workflow.launchDir'
  }
}
#####################
step_configurations = y[["steps"]]
# XML STRING 
prefix.xml <- "
<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>
"


# BUILD XML TREE
#doc = xmlTreeParse(prefix.xml,useInternalNodes = T)     # PARSE STRING
rlog::log_info(paste("STEP3:Generating ICA XML based off of",nf_params_json))
doc = newXMLDoc()
#xmlAttrs(doc) = c(encoding="UTF-8",standalone="yes")
#root = xmlRoot(doc)                                      # FIND ROOT
#pipeline_node = newXMLNode("pipeline",parent=root)
root = newXMLNode("pipeline",doc=doc)
xmlAttrs(root) = c(code=paste(basename(dirname(nf_params_json)),"pipeline"),version="1.0",xmlns="xsd://www.illumina.com/ica/cp/pipelinedefinition")
# add data inputs
# create new sections for steps
## then add options for each section
############
#code="left" format="FASTQ" type="FILE" required="true" multiValue="false"
#<pd:dataInput code="ref" format="FASTA" type="FILE" required="true" multiValue="false">
#  <pd:label>ref</pd:label>
#  <pd:description>the value for File transcriptome</pd:description>
#  </pd:dataInput>
############
#############################
#### add data inputs
rlog::log_info(paste("STEP3a: Adding dataInputs"))
dataInputsNode = newXMLNode("dataInputs",parent=root)
if(length(data_input_configurations) >0){
  for(i in 1:length(names(data_input_configurations))){
    dataInputNode = newXMLNode("dataInput",parent=dataInputsNode)
    if(grepl("folder",data_input_configurations[[names(data_input_configurations)[i]]][["description"]],ignore.case=T)){
      xmlAttrs(dataInputNode) = c(code = names(data_input_configurations)[i] ,format = "UNKNOWN",type = "FOLDER",required = "true",multiValue = "true")   
  } else{
      if(names(data_input_configurations)[i]  == "input_files" && data_input_configurations[[names(data_input_configurations)[i]]][["description"]] == 'input files for pipeline.\nAll files will be staged in workflow.launchDir'){
        xmlAttrs(dataInputNode) = c(code = names(data_input_configurations)[i] ,format = "UNKNOWN",type = "FILE",required = "false",multiValue = "true")   
      } else{
        xmlAttrs(dataInputNode) = c(code = names(data_input_configurations)[i] ,format = "UNKNOWN",type = "FILE",required = "true",multiValue = "true")   
      }
    }
    newXMLNode("label", names(data_input_configurations)[i], parent=dataInputNode)
    newXMLNode("description", data_input_configurations[[names(data_input_configurations)[i]]][["description"]], parent=dataInputNode)
  }
} else{
  rlog::log_warn(paste("STEP3a: No dataInputs found"))
}
############## add parameter options
## <pd:step execution="MANDATORY" code="General">
#<pd:label>General</pd:label>
#  <pd:description>General parameters</pd:description>
#  <pd:tool code="generalparameters">
#  <pd:label>generalparameters</pd:label>
#  <pd:description>General Parameters</pd:description>

#code="threads" minValues="1" maxValues="1" classification="USER"
#
#                <pd:parameter code="threads" minValues="1" maxValues="1" classification="USER">
#                    <pd:label>threads</pd:label>
#                    <pd:description>the value for threads</pd:description>
#                    <pd:integerType/>
#                    <pd:value>8</pd:value>
#                </pd:parameter>
############  
########################
rlog::log_info(paste("STEP3b: Adding parameter options"))
stepsNode = newXMLNode("steps",parent=root)
if(length(step_configurations)>0){
  for(i in 1:length(names(step_configurations))){
    initial_step_node = newXMLNode("step",parent=stepsNode)
    xmlAttrs(initial_step_node) = c(execution = "MANDATORY",code = names(step_configurations)[i])    
    step_label_node  = newXMLNode("label",names(step_configurations)[i],parent=initial_step_node)
    description_label_node  = newXMLNode("description",paste(names(step_configurations)[i],"parameters"),parent=initial_step_node)
    tool_description_node = newXMLNode("tool",parent=initial_step_node)
    xmlAttrs(tool_description_node) = c(code=paste(names(step_configurations)[i],"parameters"))
    nested_step_label_node  = newXMLNode("label",names(step_configurations)[i],parent=tool_description_node)
    nested_description_label_node  = newXMLNode("description",paste(names(step_configurations)[i],"parameters"),parent=tool_description_node)
    parameter_names = names(step_configurations[[names(step_configurations)[i]]])
    for(j in 1:length(parameter_names)){
      parameter_metadata = step_configurations[[names(step_configurations[i])]][[parameter_names[j]]]
      nested_parameter_node = newXMLNode("parameter",parent=tool_description_node)
      xmlAttrs(nested_parameter_node) = c(code = names(step_configurations[[names(step_configurations)[i]]])[j],minValues = "1",maxValues="1",classification="USER")
      newXMLNode("label",parameter_names[j],parent=nested_parameter_node)
      newXMLNode("description",parameter_metadata[["description"]],parent=nested_parameter_node)
      #### adding options if a list of values are provided
      if("list" %in% names(parameter_metadata)){
        list_vals = parameter_metadata[["list"]]
        if(length(list_vals) > 0){
          options_node = newXMLNode(paste("optionsType"),parent=nested_parameter_node)
          for(lv in 1:length(list_vals)){
            newXMLNode("option",list_vals[lv],parent=options_node)
          }
        }
      } else{
        if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
          newXMLNode(paste("integer","Type",sep=""),parent=nested_parameter_node)
        } else{
          newXMLNode(paste(paste(parameter_metadata[["type"]],"Type",sep=""),sep=""),parent=nested_parameter_node)
        }
      }
      if("default" %in% names(parameter_metadata)){
        dummy_value = ""
        if(parameter_metadata[["default"]] != ""){
          if(parameter_metadata[["default"]] == FALSE){
            parameter_metadata[["default"]] = "false"
          } else if(parameter_metadata[["default"]] == TRUE){
            parameter_metadata[["default"]] = "true"
          }
        } else{
          if(parameter_metadata[["type"]] == "boolean"){
            dummy_value = "false"
          } else if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
            dummy_value = 0
          } else{
            dummy_value = "null"
          }
          parameter_metadata[["default"]] = dummy_value
        }
        newXMLNode("value",parameter_metadata[["default"]],parent=nested_parameter_node)
      } else{
        dummy_value = ""
        if(parameter_metadata[["type"]] == "boolean"){
          dummy_value = "false"
        } else if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
          dummy_value = 0
        } else{
          dummy_value = "null"
        }
        newXMLNode("value",dummy_value,parent=nested_parameter_node)
      }
    }
  }
} else{
  rlog::log_warn(paste("STEP3a: No parameters found"))
}
# VIEW XML
#print(doc)

# SAVE XML TO FILE
outputFile = paste(basename(dirname(nf_params_json)), "pipeline","xml",sep=".")
if(!is.null(args$output)){
  outputPath = args$output
} else{
  outputPath = paste(dirname(nf_params_json),"/",outputFile,sep="")
}
rlog::log_info(paste("STEP4: Generating parameters XML to",outputPath))
#prefix='<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'
saveXML(doc, file=outputPath,encoding="utf-8")